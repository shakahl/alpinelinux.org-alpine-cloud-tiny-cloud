#!/bin/sh
# vim:set ts=4 et ft=sh:

# Tiny Cloud

set -e

: "${LIBDIR:=$PREFIX/lib}"
. "$LIBDIR/tiny-cloud/common"

usage() {
    cat <<EOF
Usage: ${0##*/} [-h | --help] { early | main | final | --bootstrap {complete|incomplete} | --setup }
EOF
}

init__bootstrap_complete() {
    touch "$TINY_CLOUD_VAR/.bootstrap-complete"
}
bootstrap_incomplete() {
    rm -f "$TINY_CLOUD_VAR/.bootstrap-complete"
}

args=$(getopt -o hsb: --long help,setup,bootstrap: -n ${0##*/} -- "$@")
if [ $? -ne 0 ] || [ $# -eq 0 ]; then
    usage >&2
    exit 1
fi
eval set -- "$args"
while true; do
    case "$1" in
        -h|--help) usage; exit 0;;
        -b|--bootstrap) shift
            case "$1" in
                complete)   # indicate bootstrap is done
                    init__bootstrap_complete
                    log warn 'bootstrap marked complete';;
                incomplete) # indicate bootstrap isn't done
                    bootstrap_incomplete
                    log warn 'bootstrap marked incomplete';;
                *) usage >&2; exit 1;;
            esac
            printf ' bootstrap marked "%s"\n' "$1" >&2
            exit 0;;
        -s|--setup) # just openrc for now
            for phase in -early '' -final; do
                rc-update -a del "tiny-cloud$phase" || true
            done
            rc-update add tiny-cloud-early boot
            rc-update add tiny-cloud default
            rc-update add tiny-cloud-final default
            exit 0;;
        --) shift; break;;
        *) usage >&2; exit 1;;
    esac
    shift
done

phase="$1"
shift

case "$phase" in
    early|main|final) ;;
    *) usage >&2; exit 1;;
esac

# is initial bootstrap already done?
if [ -f "$TINY_CLOUD_VAR/.bootstrap-complete" ]; then
    printf ' already bootstrapped\n' >&2
    log info "$phase - already bootstrapped"
    exit 0;
fi

# load init functions
. "$LIBDIR/tiny-cloud/init"

### non-overrideable stuff

# should we skip this action?
skip_action() {
    local action="$1"
    for i in $SKIP_INIT_ACTIONS; do
        [ "$i" = "$action" ] && return 0
    done
    return 1
}

# mandatory final action...
INIT_ACTIONS_FINAL="${INIT_ACTIONS_FINAL} bootstrap_complete"

### let's do stuff!

case "$phase" in
    early)  INIT_ACTIONS="$INIT_ACTIONS_EARLY";;
    main)   INIT_ACTIONS="$INIT_ACTIONS_MAIN";;
    final)  INIT_ACTIONS="$INIT_ACTIONS_FINAL";;
    *)      usage >&2; exit 1
esac

for ACTION in $INIT_ACTIONS; do
    if skip_action "$ACTION"; then
        printf '\n  -- %s : [SKIP]' $ACTION >&2
        log warn "$phase - $ACTION - SKIPPED"
        continue
    fi
    printf '\n  ++ %s ' $ACTION >&2
    log info "$phase - $ACTION - START"
    RESULT="UNKNOWN"
    LEVEL="err"
    if type "init__$ACTION" | grep -q -w "function"; then
        if "init__$ACTION" "$@"; then
            RESULT="DONE"
            LEVEL="info"
        else
            RESULT="FAIL"
        fi
    fi
    printf ': [%s]' $RESULT >&2
    log "$LEVEL" "$phase - $ACTION - $RESULT"
done
echo >&2
